import { combineArrays } from '../../utils';
import { NautilusAsset } from './NautilusAsset';
import { NautilusDDO } from './NautilusDDO';
export class AssetBuilder {
    asset;
    constructor(aquariusAsset) {
        if (aquariusAsset) {
            const nautilusDDO = NautilusDDO.createFromAquariusAsset(aquariusAsset);
            this.asset = new NautilusAsset(nautilusDDO);
            this.asset.owner = aquariusAsset.nft.owner;
            this.asset.lifecycleState = aquariusAsset.nft.state;
        }
        else {
            this.asset = new NautilusAsset();
        }
    }
    reset() {
        this.asset = new NautilusAsset();
    }
    setType(type) {
        this.asset.ddo.metadata.type = type;
        return this;
    }
    setName(name) {
        this.asset.ddo.metadata.name = name;
        return this;
    }
    setDescription(description) {
        this.asset.ddo.metadata.description = description;
        return this;
    }
    setLicense(license) {
        this.asset.ddo.metadata.license = license;
        return this;
    }
    setAuthor(author) {
        this.asset.ddo.metadata.author = author;
        return this;
    }
    setAlgorithm(algorithm) {
        this.asset.ddo.metadata.algorithm = algorithm;
        return this;
    }
    addService(service) {
        this.asset.ddo.services.push(service);
        return this;
    }
    removeService(serviceId) {
        this.asset.ddo.removeServices.push(serviceId);
        return this;
    }
    setNftData(tokenData) {
        this.asset.nftCreateData = tokenData;
        return this;
    }
    setLifecycleState(state) {
        this.asset.lifecycleState = state;
        return this;
    }
    setOwner(owner) {
        this.asset.owner = owner;
        return this;
    }
    // biome-ignore lint/suspicious/noExplicitAny: can be any user info
    addAdditionalInformation(additionalInformation) {
        this.asset.ddo.metadata.additionalInformation = {
            ...this.asset.ddo.metadata.additionalInformation,
            ...additionalInformation
        };
        return this;
    }
    setCopyrightHolder(copyrightHolder) {
        this.asset.ddo.metadata.copyrightHolder = copyrightHolder;
        return this;
    }
    addTags(tags) {
        this.asset.ddo.metadata.tags = combineArrays(this.asset.ddo.metadata.tags || [], tags);
        return this;
    }
    addLinks(links) {
        this.asset.ddo.metadata.links = combineArrays(this.asset.ddo.metadata.links || [], links);
        return this;
    }
    // TODO: add check for correct language tag
    // https://www.rfc-editor.org/info/bcp47
    setContentLanguage(language) {
        this.asset.ddo.metadata.contentLanguage = language;
        return this;
    }
    addCategories(categories) {
        this.asset.ddo.metadata.categories = combineArrays(this.asset.ddo.metadata.categories || [], categories);
        return this;
    }
    addCredentialAddresses(list, addresses) {
        // first get the index of the address credential list
        const addressCredentialIndex = this.asset.ddo.credentials[list].findIndex((credential) => credential.type === 'address');
        // get addresses already added to the credential values
        const oldAddresses = this.asset.ddo.credentials[list][addressCredentialIndex]?.values || [];
        // add new values and remove duplicates
        const newAddresses = combineArrays(oldAddresses, addresses);
        // update the existing credential or add a new one for type address
        if (addressCredentialIndex > -1)
            this.asset.ddo.credentials[list][addressCredentialIndex].values =
                newAddresses;
        else
            this.asset.ddo.credentials[list].push({
                type: 'address',
                values: newAddresses
            });
        return this;
    }
    removeCredentialAddresses(list, addresses) {
        // first get the index of the address credential list
        const addressCredentialIndex = this.asset.ddo.credentials[list].findIndex((credential) => credential.type === 'address');
        if (addressCredentialIndex === -1)
            return this;
        // get addresses already added to the credential values
        const oldAddresses = this.asset.ddo.credentials[list][addressCredentialIndex]?.values;
        const newAddresses = oldAddresses.filter((address) => !addresses.includes(address));
        if (newAddresses.length > 0) {
            this.asset.ddo.credentials[list][addressCredentialIndex].values =
                newAddresses;
        }
        else {
            this.asset.ddo.credentials[list].splice(addressCredentialIndex, 1);
        }
        return this;
    }
    build() {
        // TODO: look for errors / missing input
        return this.asset;
    }
}
//# sourceMappingURL=AssetBuilder.js.map