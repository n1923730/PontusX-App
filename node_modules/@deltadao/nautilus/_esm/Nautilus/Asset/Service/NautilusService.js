import { getHash } from '@oceanprotocol/lib';
import { getEncryptedFiles, getFileInfo, isValidProvider } from '../../../utils/provider';
import { params as DatatokenConstantParams } from '../constants/datatoken.constants';
export var FileTypes;
(function (FileTypes) {
    FileTypes["URL"] = "url";
    FileTypes["GRAPHQL"] = "graphql";
    FileTypes["ARWEAVE"] = "arweave";
    FileTypes["IPFS"] = "ipfs";
    FileTypes["SMARTCONTRACT"] = "smartcontract";
})(FileTypes || (FileTypes = {}));
export var ServiceTypes;
(function (ServiceTypes) {
    ServiceTypes["ACCESS"] = "access";
    ServiceTypes["COMPUTE"] = "compute";
})(ServiceTypes || (ServiceTypes = {}));
/**
 * @internal
 */
export class NautilusService {
    type;
    serviceEndpoint;
    timeout;
    files = [];
    existingEncryptedFiles;
    pricing;
    newPrice;
    datatokenCreateParams;
    editExistingService;
    filesEdited;
    serviceEndpointEdited;
    name;
    description;
    compute = {
        allowNetworkAccess: false,
        allowRawAlgorithm: false,
        publisherTrustedAlgorithmPublishers: [],
        publisherTrustedAlgorithms: []
    };
    addedPublisherTrustedAlgorithms = [];
    consumerParameters = [];
    // biome-ignore lint/suspicious/noExplicitAny: can be any user defined information
    additionalInformation;
    id;
    datatokenAddress;
    constructor() {
        this.editExistingService = false;
        this.filesEdited = false;
        this.initDatatokenData();
    }
    initDatatokenData() {
        this.datatokenCreateParams = DatatokenConstantParams;
    }
    async getOceanService(chainId, nftAddress, dtAddress) {
        if (!(await this.hasValidServiceEndpoint()))
            throw new Error('serviceEndpoint is not a valid Ocean Provider');
        if (!(await this.hasValidFiles()))
            throw new Error('Some of the provided files could not be validated');
        const datatokenAddress = dtAddress || this.datatokenAddress;
        if (!datatokenAddress)
            throw new Error('datatokenAddress is required');
        const isFilesObjectChanged = this.checkIfFilesObjectChanged();
        let encryptedFiles;
        if (isFilesObjectChanged || !this.existingEncryptedFiles) {
            if (this.files.length < 1) {
                throw new Error('Can not encrypt files. No files defined!');
            }
            const assetURL = {
                datatokenAddress,
                nftAddress,
                files: this.files
            };
            encryptedFiles = await getEncryptedFiles(assetURL, chainId, this.serviceEndpoint);
        }
        else {
            encryptedFiles = this.existingEncryptedFiles;
        }
        // required attributes
        const oceanService = {
            id: this.id && !isFilesObjectChanged ? this.id : getHash(encryptedFiles),
            datatokenAddress,
            type: this.type,
            serviceEndpoint: this.serviceEndpoint,
            timeout: this.timeout,
            files: encryptedFiles
        };
        // add optional attributes if they are defined
        if (this.name)
            oceanService.name = this.name;
        if (this.description)
            oceanService.description = this.description;
        if (this.additionalInformation)
            oceanService.additionalInformation = this.additionalInformation;
        if (this.consumerParameters.length > 0)
            oceanService.consumerParameters = this.consumerParameters;
        // we only add the compute attribute for `compute` type services
        if (this.type === ServiceTypes.COMPUTE)
            oceanService.compute = this.compute;
        return oceanService;
    }
    async hasValidServiceEndpoint() {
        return await isValidProvider(this.serviceEndpoint);
    }
    async hasValidFiles() {
        for (const file of this.files) {
            const fileInfo = await getFileInfo(file, this.serviceEndpoint);
            if (fileInfo.some((info) => !info.valid))
                return false;
        }
        return true;
    }
    checkIfFilesObjectChanged() {
        return ((this.editExistingService &&
            (this.filesEdited || this.serviceEndpointEdited)) ||
            !!this.pricing);
    }
}
//# sourceMappingURL=NautilusService.js.map