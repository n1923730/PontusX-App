import { LoggerInstance, ProviderInstance, approveWei } from '@oceanprotocol/lib';
import { getOceanConfig } from '.';
export async function isValidProvider(providerUrl) {
    try {
        // https://github.com/oceanprotocol/provider/blob/v4main/API.md#encrypt-endpoint
        const response = await ProviderInstance.isValidProvider(providerUrl);
        return response;
    }
    catch (error) {
        LoggerInstance.error(`Error verifying provider instance: ${error.message}`);
        return false;
    }
}
export async function getEncryptedFiles(
// biome-ignore lint/suspicious/noExplicitAny: ProviderInstance.encrypt data is type any
files, chainId, providerUrl) {
    try {
        // https://github.com/oceanprotocol/provider/blob/v4main/API.md#encrypt-endpoint
        LoggerInstance.debug('Encrytping files:');
        LoggerInstance.debug({ files, chainId, providerUrl });
        const response = await ProviderInstance.encrypt(files, chainId, providerUrl);
        return response;
    }
    catch (error) {
        LoggerInstance.error(`Error parsing json: ${error.message}`);
    }
}
export async function checkDidFiles(did, serviceId, providerUrl) {
    try {
        const response = await ProviderInstance.checkDidFiles(did, serviceId, providerUrl, true);
        return response;
    }
    catch (error) {
        throw new Error(`[Initialize check file did] Error:' ${error}`);
    }
}
export async function initializeProvider(asset, accountId, service, fileIndex = 0, consumerParameters) {
    try {
        return await ProviderInstance.initialize(asset.id, service.id, fileIndex, accountId, service.serviceEndpoint, undefined, consumerParameters);
    }
    catch (error) {
        LoggerInstance.error('Error initializing provider for access!');
        LoggerInstance.error(error);
        return null;
    }
}
export async function initializeProviderForCompute(dataset, algorithm, accountId, computeEnv = null) {
    const computeAsset = {
        documentId: dataset.id,
        serviceId: dataset.services[0].id,
        transferTxId: dataset.accessDetails.validOrderTx
    };
    const computeAlgo = {
        documentId: algorithm.id,
        serviceId: algorithm.services[0].id,
        transferTxId: algorithm.accessDetails.validOrderTx
    };
    const validUntil = getValidUntilTime(computeEnv?.maxJobDuration, dataset.services[0].timeout, algorithm.services[0].timeout);
    try {
        return await ProviderInstance.initializeCompute([computeAsset], computeAlgo, computeEnv?.id, validUntil, dataset.services[0].serviceEndpoint, accountId);
    }
    catch (error) {
        LoggerInstance.error(`Error initializing provider for the compute job! ${error.message}`);
        return null;
    }
}
export async function startComputeJob(providerUri, dataset, algorithm, signer, computeEnv, output) {
    try {
        return await ProviderInstance.computeStart(providerUri, signer, computeEnv?.id, dataset, algorithm, null, null, output);
    }
    catch (error) {
        LoggerInstance.error('Error starting compute job!');
        LoggerInstance.error(error);
    }
}
export async function stopComputeJob(providerUri, did, jobId, signer) {
    try {
        return await ProviderInstance.computeStop(did, await signer.getAddress(), jobId, providerUri, signer);
    }
    catch (error) {
        LoggerInstance.error('Error stopping compute job!');
        LoggerInstance.error(error);
    }
}
export function getValidUntilTime(computeEnvMaxJobDuration, datasetTimeout, algorithmTimeout) {
    const inputValues = [];
    computeEnvMaxJobDuration && inputValues.push(computeEnvMaxJobDuration);
    datasetTimeout && inputValues.push(datasetTimeout);
    algorithmTimeout && inputValues.push(algorithmTimeout);
    const minValue = Math.min(...inputValues);
    const mytime = new Date();
    mytime.setMinutes(mytime.getMinutes() + Math.floor(minValue / 60));
    return Math.floor(mytime.getTime() / 1000);
}
export async function approveProviderFee(asset, accountId, signer, providerFeeAmount) {
    const config = getOceanConfig(asset.chainId);
    const baseToken = asset?.accessDetails?.type === 'free'
        ? getOceanConfig(asset.chainId).oceanTokenAddress
        : asset?.accessDetails?.baseToken?.address;
    const txApproveWei = await approveWei(signer, config, accountId, baseToken, asset?.accessDetails?.datatoken?.address, providerFeeAmount);
    return txApproveWei;
}
export async function getFileInfo(file, providerUri, withChecksum) {
    return await ProviderInstance.getFileInfo(file, providerUri, withChecksum);
}
//# sourceMappingURL=provider.js.map