import { ConfigHelper, Datatoken } from '@oceanprotocol/lib';
export function getOceanConfig(chainId, infuraProjectId) {
    const config = new ConfigHelper().getConfig(chainId, infuraProjectId);
    return config;
}
export function getServiceById(asset, serviceId) {
    if (!asset)
        return;
    return asset.services?.find((s) => s.id === serviceId);
}
export function getServiceByName(asset, serviceName) {
    if (!asset)
        return;
    return asset.services?.find((s) => s.type === serviceName);
}
export async function getDatatokenBalance(signer, datatokenAddress) {
    return Number(await new Datatoken(signer).balance(datatokenAddress, await signer.getAddress()));
}
export function dateToStringNoMS(date) {
    return date.toISOString().replace(/\.[0-9]{3}Z/, 'Z');
}
export function getAllPromisesOnArray(array, promise) {
    return Promise.all(array.map((e) => promise(e)));
}
/**
 * Filters an array to remove any duplicate values
 * @param array the array to filter
 * @returns an array containing only unique entries
 */
export function removeDuplicatesFromArray(array) {
    return array.filter((value, index, array) => array.indexOf(value) === index);
}
/**
 * Combines two arrays and returns an array containing only unique values
 * @param arrayOne first array
 * @param arrayTwo second array
 * @returns array with combination of only unique entries
 */
export function combineArrays(arrayOne, arrayTwo) {
    const newArray = arrayOne.concat(arrayTwo);
    return removeDuplicatesFromArray(newArray);
}
/**
 * Combines two arrays and replaces items in the base array with new items based on a customizable function.
 * @param array the base array for the combination
 * @param newItems the new items to replace existing ones, or be added to the base array
 * @param replace the function to replace a given item with any of the new items
 * @returns a combination of the base array, containing all base items, or their respective replacements, and any leftover new items of the newItems array
 */
export function combineArraysAndReplaceItems(array, newItems, replace) {
    const arrayWithReplacedItems = [];
    // loop through all existing items and replace based on the replace() function of user
    for (const existingItem of array) {
        const replacedItem = replace(existingItem, newItems);
        // if the replacement was taken from newItems...
        const replaceItemIndexInNewItems = newItems.indexOf(replacedItem);
        // ... we want to remove it, to avoid having duplicate entries in final array combination
        if (replaceItemIndexInNewItems > -1) {
            newItems.splice(replaceItemIndexInNewItems, 1);
        }
        // add the replacement to the return array
        arrayWithReplacedItems.push(replacedItem);
    }
    // return a combination of all replacements and "non-duplicate" newItems
    return combineArrays(arrayWithReplacedItems, newItems);
}
//# sourceMappingURL=index.js.map