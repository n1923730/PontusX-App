"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServiceWithDatatokenAndPricing = exports.publishDDO = exports.createAsset = void 0;
const lib_1 = require("@oceanprotocol/lib");
const ethers_1 = require("ethers");
const _types_1 = require("../@types");
async function createAsset(assetConfig) {
    lib_1.LoggerInstance.debug('[publish] Publishing new asset NFT...');
    const { signer, chainConfig, nftParams } = assetConfig;
    const nftFactory = new lib_1.NftFactory(chainConfig.nftFactoryAddress, signer, chainConfig.network, chainConfig);
    const nftAddress = await nftFactory.createNFT(nftParams);
    lib_1.LoggerInstance.debug('[publish] NFT published:', nftAddress);
    return { nftAddress };
}
exports.createAsset = createAsset;
async function createDatatokenAndPricing(config) {
    lib_1.LoggerInstance.debug('[publish] Creating datatoken...');
    const { chainConfig, signer, nftAddress, datatokenParams, pricing } = config;
    const publisherAccount = await signer?.getAddress();
    const nft = new lib_1.Nft(signer, chainConfig.network, chainConfig);
    const datatokenAddress = await nft.createDatatoken(nftAddress, publisherAccount, datatokenParams.minter, datatokenParams.paymentCollector, datatokenParams.mpFeeAddress, datatokenParams.feeToken, datatokenParams.feeAmount, datatokenParams.cap, datatokenParams.name, datatokenParams.symbol, datatokenParams.templateIndex);
    lib_1.LoggerInstance.debug('[publish] Datatoken created.', datatokenAddress);
    const datatoken = new lib_1.Datatoken(signer, chainConfig.network, chainConfig);
    const dispenserParams = {
        maxTokens: ethers_1.utils.parseEther('1').toString(),
        maxBalance: ethers_1.utils.parseEther('1').toString(),
        withMint: true,
        allowedSwapper: '0x0000000000000000000000000000000000000000'
    };
    let pricingTransactionReceipt;
    switch (pricing.type) {
        case 'fixed':
            lib_1.LoggerInstance.debug('[publish] Creating fixed rate exchange for datatoken...', { datatokenAddress, pricing });
            pricingTransactionReceipt = await datatoken.createFixedRate(datatokenAddress, publisherAccount, {
                ...pricing.freCreationParams,
                fixedRate: ethers_1.utils
                    .parseEther(pricing.freCreationParams.fixedRate)
                    .toString(),
                marketFee: ethers_1.utils
                    .parseEther(pricing.freCreationParams.marketFee)
                    .toString()
            });
            break;
        case 'free':
            lib_1.LoggerInstance.debug('[publish] Creating dispenser for datatoken...', {
                pricing,
                datatokenAddress,
                publisherAccount,
                dispenserAddress: chainConfig.dispenserAddress,
                dispenserParams
            });
            pricingTransactionReceipt = await datatoken.createDispenser(datatokenAddress, publisherAccount, chainConfig.dispenserAddress, dispenserParams);
            break;
    }
    lib_1.LoggerInstance.debug('[publish] Pricing scheme created.', pricingTransactionReceipt);
    const tx = await pricingTransactionReceipt.wait();
    return { datatokenAddress, tx };
}
async function publishDDO(config) {
    const { chainConfig, signer, ddo, asset } = config;
    const publisherAccount = await signer?.getAddress();
    lib_1.LoggerInstance.debug(`[publish] Validating DDO via ${chainConfig.metadataCacheUri}`);
    const aquarius = new lib_1.Aquarius(chainConfig.metadataCacheUri);
    const validateResult = await aquarius.validate(ddo);
    if (!validateResult.valid)
        throw new Error(`Validating Metadata failed: ${validateResult?.errors}`);
    lib_1.LoggerInstance.debug('[publish] Encrypting DDO...');
    const encryptedDDO = await lib_1.ProviderInstance.encrypt(ddo, chainConfig.chainId, chainConfig.providerUri);
    if (!encryptedDDO)
        throw new Error('No encrypted DDO received. Please try again.');
    const nft = new lib_1.Nft(signer, chainConfig.network, chainConfig);
    const lifecycleState = asset?.lifecycleState || _types_1.LifecycleStates.ACTIVE;
    const FLAGS = '0x02';
    lib_1.LoggerInstance.debug(`[publish] Asset lifecycleState: ${lifecycleState}`);
    lib_1.LoggerInstance.debug('[publish] Set Metadata...');
    const transactionReceipt = await nft.setMetadata(ddo.nftAddress, publisherAccount, lifecycleState, chainConfig.providerUri, '', FLAGS, encryptedDDO, validateResult.hash);
    const tx = await transactionReceipt.wait();
    lib_1.LoggerInstance.debug('[publish] Published metadata on NFT.', {
        ddo,
        tx
    });
    return tx;
}
exports.publishDDO = publishDDO;
async function createServiceWithDatatokenAndPricing(service, signer, chainConfig, nftAddress, assetOwner) {
    const { datatokenAddress, tx } = await createDatatokenAndPricing({
        signer,
        chainConfig,
        nftAddress,
        pricing: {
            ...service.pricing,
            freCreationParams: {
                ...service.pricing.freCreationParams,
                owner: assetOwner
            }
        },
        datatokenParams: {
            ...service.datatokenCreateParams,
            minter: assetOwner,
            paymentCollector: assetOwner
        }
    });
    service.datatokenAddress = datatokenAddress;
    return { service, datatokenAddress, tx };
}
exports.createServiceWithDatatokenAndPricing = createServiceWithDatatokenAndPricing;
//# sourceMappingURL=index.js.map