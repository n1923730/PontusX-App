"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stopCompute = exports.handleComputeOrder = exports.getComputeEnviroment = exports.retrieveResult = exports.getStatus = exports.compute = void 0;
const lib_1 = require("@oceanprotocol/lib");
const utils_1 = require("../utils");
const assets_1 = require("../utils/helpers/assets");
const order_1 = require("../utils/order");
const provider_1 = require("../utils/provider");
async function compute(computeConfig) {
    const { dataset: datasetConfig, algorithm: algorithmConfig, signer, chainConfig, additionalDatasets: additionalDatasetsConfig } = computeConfig;
    const signerAddress = await signer.getAddress();
    if (!datasetConfig || !algorithmConfig || !signer || !signerAddress) {
        lib_1.LoggerInstance.error('Missing config(s)', {
            datasetConfig,
            algorithmConfig,
            account: signerAddress
        });
        throw new Error('Cannot start compute. Missing config(s).');
    }
    const datasetDid = datasetConfig.did;
    const algorithmDid = algorithmConfig.did;
    lib_1.LoggerInstance.log('[compute] Starting compute order for dataset', datasetDid, '\nwith algorithm', algorithmDid, '\nfor account', signerAddress);
    const assetIdentifiers = [datasetConfig, algorithmConfig];
    if (additionalDatasetsConfig)
        for (const dataset of additionalDatasetsConfig)
            assetIdentifiers.push(dataset);
    try {
        const assets = await (0, assets_1.getAssetsWithAccessDetails)(assetIdentifiers, chainConfig, signer);
        const dataset = assets.find((asset) => asset.id === datasetDid);
        const algo = assets.find((asset) => asset.id === algorithmDid);
        const _additionalDatasets = additionalDatasetsConfig
            ? assets.filter((asset) => additionalDatasetsConfig
                .map((dataset) => dataset.did)
                .includes(asset.id))
            : [];
        const computeService = (0, utils_1.getServiceByName)(dataset, 'compute');
        const allowed = await (0, order_1.isOrderable)(dataset, computeService.id, {
            documentId: algo.id,
            serviceId: algo.services[0].id
        }, algo);
        lib_1.LoggerInstance.debug('[compute] Is dataset orderable?', allowed);
        if (!allowed)
            throw new Error('Dataset is not orderable in combination with given algorithm.');
        const computeEnv = await getComputeEnviroment(dataset);
        lib_1.LoggerInstance.debug('Initializing provider for compute');
        const providerInitializeResults = await (0, provider_1.initializeProviderForCompute)(dataset, algo, signerAddress, computeEnv);
        const { datasetWithPrice, algorithmWithPrice } = await getComputeAssetPrices(algo, dataset, signer, chainConfig, providerInitializeResults);
        if (!datasetWithPrice?.orderPriceAndFees)
            throw new Error('Error setting dataset price and fees!');
        if (!algorithmWithPrice?.orderPriceAndFees)
            throw new Error('Error setting algorithm price and fees!');
        const _algoDatatokenBalance = await (0, utils_1.getDatatokenBalance)(signer, algo.services[0].datatokenAddress);
        const algorithmOrderTx = await handleComputeOrder(signer, algo, algorithmWithPrice?.orderPriceAndFees, signerAddress, providerInitializeResults.algorithm, chainConfig, computeEnv.consumerAddress);
        if (!algorithmOrderTx)
            throw new Error('Failed to order algorithm.');
        const _datasetDatatokenBalance = await (0, utils_1.getDatatokenBalance)(signer, algo.services[0].datatokenAddress);
        const datasetOrderTx = await handleComputeOrder(signer, dataset, datasetWithPrice?.orderPriceAndFees, signerAddress, providerInitializeResults.datasets[0], chainConfig, computeEnv.consumerAddress);
        if (!datasetOrderTx)
            throw new Error('Failed to order dataset.');
        lib_1.LoggerInstance.log('[compute] Starting compute job.');
        const computeAsset = {
            documentId: datasetConfig.did,
            serviceId: dataset.services[0].id,
            transferTxId: datasetOrderTx,
            ...datasetConfig
        };
        const output = {
            publishAlgorithmLog: true,
            publishOutput: true
        };
        const response = await (0, provider_1.startComputeJob)(dataset.services[0].serviceEndpoint, computeAsset, {
            documentId: algorithmConfig.did,
            serviceId: algo.services[0].id,
            transferTxId: algorithmOrderTx,
            ...algorithmConfig
        }, signer, computeEnv, output);
        lib_1.LoggerInstance.debug('[compute] Starting compute job response: ', response);
        return response;
    }
    catch (e) {
        lib_1.LoggerInstance.error(e);
        lib_1.LoggerInstance.error('Failed computation:', e.message);
    }
}
exports.compute = compute;
async function getComputeAssetPrices(algo, dataset, signer, config, providerInitializeResults) {
    lib_1.LoggerInstance.debug('Initializing provider for compute');
    const datatokenAddresses = dataset.datatokens.map((dt) => dt.address);
    const datasetInitializeResult = providerInitializeResults.datasets.find((initializeResult) => datatokenAddresses.includes(initializeResult.datatoken));
    const datasetWithPrice = await (0, assets_1.getAssetWithPrice)(dataset, signer, config, datasetInitializeResult.providerFee);
    if (!datasetWithPrice?.orderPriceAndFees)
        throw new Error('Error setting dataset price and fees!');
    const algorithmWithPrice = await (0, assets_1.getAssetWithPrice)(algo, signer, config, providerInitializeResults.algorithm.providerFee);
    if (!algorithmWithPrice?.orderPriceAndFees)
        throw new Error('Error setting algorithm price and fees!');
    return { datasetWithPrice, algorithmWithPrice };
}
async function getStatus(computeStatusConfig) {
    const { jobId, signer, providerUri } = computeStatusConfig;
    const signerAddress = await signer.getAddress();
    lib_1.LoggerInstance.debug('[compute] Retrieve job status:', {
        jobId,
        providerUri,
        account: signerAddress
    });
    try {
        const status = await lib_1.ProviderInstance.computeStatus(providerUri, signerAddress, jobId);
        lib_1.LoggerInstance.debug('[compute] computeStatus response: ', status);
        return Array.isArray(status)
            ? status.find((job) => job.jobId === jobId)
            : status;
    }
    catch (e) {
        lib_1.LoggerInstance.error(e);
    }
}
exports.getStatus = getStatus;
async function retrieveResult(computeResultConfig) {
    const { providerUri, signer, jobId, resultIndex } = computeResultConfig;
    const job = await getStatus(computeResultConfig);
    if (job?.status !== 70) {
        lib_1.LoggerInstance.log('[compute] Retrieve results: job does not exist or is not yet finished.');
        return;
    }
    if (!job?.results || job.results.length < 1) {
        lib_1.LoggerInstance.error('[compute] Retrieve results: could not find results for the job.');
        return;
    }
    const index = resultIndex ||
        job.results.indexOf(job.results.find((result) => result.type === 'output'));
    if (index < 0) {
        lib_1.LoggerInstance.error('[compute] Retrieve results: resultIndex needs to be specified. No default output result found.', index);
        return;
    }
    lib_1.LoggerInstance.debug('[compute] Build result url...');
    return await lib_1.ProviderInstance.getComputeResultUrl(providerUri, signer, jobId, index);
}
exports.retrieveResult = retrieveResult;
async function getComputeEnviroment(asset) {
    if (asset?.services[0]?.type !== 'compute')
        return null;
    try {
        const computeEnvs = await lib_1.ProviderInstance.getComputeEnvironments(asset.services[0].serviceEndpoint);
        const computeEnv = Array.isArray(computeEnvs)
            ? computeEnvs[0]
            : computeEnvs[asset.chainId][0];
        if (!computeEnv)
            return null;
        return computeEnv;
    }
    catch (e) {
        lib_1.LoggerInstance.error('[compute] Fetch compute enviroment: ', e.message);
    }
}
exports.getComputeEnviroment = getComputeEnviroment;
async function handleComputeOrder(signer, asset, orderPriceAndFees, accountId, initializeData, config, computeConsumerAddress) {
    lib_1.LoggerInstance.debug('[compute] Handle compute order for asset type: ', asset.metadata.type);
    try {
        if (initializeData?.validOrder && !initializeData?.providerFee) {
            lib_1.LoggerInstance.debug('[compute] Has valid order: ', initializeData.validOrder);
            return asset?.accessDetails?.validOrderTx;
        }
        if (initializeData?.providerFee?.providerFeeAmount &&
            initializeData?.providerFee?.providerFeeAmount !== '0') {
            const txApproveProvider = await (0, provider_1.approveProviderFee)(asset, accountId, signer, initializeData.providerFee.providerFeeAmount);
            if (!txApproveProvider)
                throw new Error('Failed to approve provider fees!');
            lib_1.LoggerInstance.debug('[compute] Approved provider fees:', txApproveProvider);
        }
        if (initializeData?.validOrder) {
            lib_1.LoggerInstance.debug('[compute] Calling reuseOrder ...', initializeData);
            const txReuseOrder = await (0, order_1.reuseOrder)({
                signer,
                asset,
                validOrderTx: initializeData.validOrder,
                providerFees: initializeData.providerFee
            });
            if (!txReuseOrder)
                throw new Error('Failed to reuse order!');
            const tx = await txReuseOrder.wait();
            lib_1.LoggerInstance.debug('[compute] Reused order:', tx);
            return tx?.transactionHash;
        }
        lib_1.LoggerInstance.debug('[compute] Calling order ...', initializeData);
        const txStartOrder = await (0, order_1.order)({
            signer,
            asset,
            orderPriceAndFees,
            accountId,
            config,
            providerFees: initializeData?.providerFee,
            computeConsumerAddress
        });
        const tx = await txStartOrder.wait();
        lib_1.LoggerInstance.debug('[compute] Order succeeded', tx);
        return tx?.transactionHash;
    }
    catch (error) {
        lib_1.LoggerInstance.error(`[compute] ${error.message}`);
    }
}
exports.handleComputeOrder = handleComputeOrder;
async function stopCompute(stopComputeConfig) {
    const { did, jobId, providerUri, signer } = stopComputeConfig;
    return await (0, provider_1.stopComputeJob)(providerUri, did, jobId, signer);
}
exports.stopCompute = stopCompute;
//# sourceMappingURL=index.js.map