"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Nautilus = exports.LogLevel = void 0;
const lib_1 = require("@oceanprotocol/lib");
const ethers_1 = require("ethers");
const _types_1 = require("../@types");
const access_1 = require("../access");
const compute_1 = require("../compute");
const publish_1 = require("../publish");
const aquarius_1 = require("../utils/aquarius");
const contracts_1 = require("../utils/contracts");
const trusted_algorithms_1 = require("../utils/helpers/trusted-algorithms");
var lib_2 = require("@oceanprotocol/lib");
Object.defineProperty(exports, "LogLevel", { enumerable: true, get: function () { return lib_2.LogLevel; } });
class Nautilus {
    signer;
    config;
    constructor(signer) {
        this.signer = signer;
    }
    static async create(signer, config) {
        lib_1.LoggerInstance.debug('Creating new Nautilus instance with signer', await signer.getAddress());
        const instance = new Nautilus(signer);
        await instance.init(config);
        return instance;
    }
    static setLogLevel(level) {
        lib_1.LoggerInstance.setLevel(level);
    }
    async init(config) {
        await this.loadOceanConfig(config);
    }
    async loadOceanConfig(config) {
        const chainId = await this.signer.getChainId();
        const oceanConfig = new lib_1.ConfigHelper().getConfig(chainId);
        if (!oceanConfig)
            lib_1.LoggerInstance.debug('No default config found for given chainId');
        this.config = {
            ...oceanConfig,
            ...config
        };
        if (!this.hasValidConfig()) {
            lib_1.LoggerInstance.error({
                config: this.config
            });
            throw Error('Cannot initialize using the given config & web3.');
        }
    }
    hasValidConfig() {
        return (this.config.chainId > 0 &&
            this.config.metadataCacheUri?.length > 0 &&
            this.config.providerUri?.length > 0 &&
            this.config.nodeUri?.length > 0 &&
            this.config.subgraphUri?.length > 0 &&
            ethers_1.utils.isAddress(this.config.fixedRateExchangeAddress) &&
            ethers_1.utils.isAddress(this.config.dispenserAddress) &&
            ethers_1.utils.isAddress(this.config.nftFactoryAddress));
    }
    getChainConfig() {
        if (!this.signer || !this.config)
            throw Error('Web3 and chainConfig are required.');
        return {
            signer: this.signer,
            chainConfig: this.config
        };
    }
    getOceanConfig() {
        return this.config;
    }
    async publish(asset) {
        const { signer, chainConfig } = this.getChainConfig();
        let { nftAddress } = asset.ddo;
        if (!nftAddress) {
            const nftCreationResult = await (0, publish_1.createAsset)({
                signer,
                chainConfig,
                nftParams: asset.getNftParams()
            });
            nftAddress = nftCreationResult.nftAddress.toString();
        }
        await (0, trusted_algorithms_1.resolvePublisherTrustedAlgorithms)(asset.ddo.services, chainConfig.metadataCacheUri);
        const services = [];
        for (const service of asset.ddo.services) {
            const serviceWithDatatokenAndPricing = await (0, publish_1.createServiceWithDatatokenAndPricing)(service, signer, chainConfig, nftAddress, asset.owner);
            services.push(serviceWithDatatokenAndPricing);
        }
        const ddo = await asset.ddo.getDDO({
            create: true,
            chainId: chainConfig.chainId,
            nftAddress
        });
        const setMetadataTxReceipt = await (0, publish_1.publishDDO)({
            signer,
            chainConfig,
            ddo,
            asset
        });
        return {
            nftAddress,
            services,
            ddo,
            setMetadataTxReceipt
        };
    }
    async edit(asset) {
        const { signer, chainConfig } = this.getChainConfig();
        const { nftAddress, services: nautilusDDOServices } = asset.ddo;
        const services = [];
        await (0, trusted_algorithms_1.resolvePublisherTrustedAlgorithms)(nautilusDDOServices, chainConfig.metadataCacheUri);
        const changedPriceServices = nautilusDDOServices.filter((nautilusService) => nautilusService.pricing);
        for (const service of changedPriceServices) {
            const serviceWithDatatokenAndPricing = await (0, publish_1.createServiceWithDatatokenAndPricing)(service, signer, chainConfig, nftAddress, asset.owner);
            services.push(serviceWithDatatokenAndPricing);
        }
        const ddo = await asset.ddo.getDDO({
            create: false,
            chainId: chainConfig.chainId,
            nftAddress
        });
        const setMetadataTxReceipt = await (0, publish_1.publishDDO)({
            signer,
            chainConfig,
            ddo,
            asset
        });
        return {
            nftAddress,
            services,
            ddo,
            setMetadataTxReceipt
        };
    }
    async setServicePrice(aquaAsset, serviceId, newPrice) {
        if (typeof newPrice !== 'string' ||
            Number.isNaN(Number.parseFloat(newPrice))) {
            throw new Error('newPrice must be a numeric string');
        }
        return await (0, contracts_1.editPrice)(aquaAsset, serviceId, newPrice, this.config, this.signer);
    }
    async getAquariusAssets(dids) {
        try {
            return await (0, aquarius_1.getAssets)(this.config.metadataCacheUri, dids);
        }
        catch (error) {
            throw new Error(`getAquariusAssets failed: ${error}`);
        }
    }
    async getAquariusAsset(did) {
        try {
            return await (0, aquarius_1.getAsset)(this.config.metadataCacheUri, did);
        }
        catch (error) {
            throw new Error(`getAquariusAsset failed: ${error}`);
        }
    }
    async setAssetLifecycleState(aquariusAsset, state) {
        const { signer } = this.getChainConfig();
        const address = await signer.getAddress();
        const nft = new lib_1.Nft(signer);
        const existingNftState = aquariusAsset.nft.state;
        if (existingNftState === state) {
            lib_1.LoggerInstance.warn(`[lifecycle] Asset lifecycle state is already ${state} (${_types_1.LifecycleStates[state]}), action aborted`);
            return;
        }
        lib_1.LoggerInstance.debug(`[lifecycle] Change asset lifecycle state from ${existingNftState} (${_types_1.LifecycleStates[existingNftState]}) to ${state} (${_types_1.LifecycleStates[state]}) `);
        const stateTxReceipt = await nft.setMetadataState(aquariusAsset.nft.address, address, state);
        const stateTx = await stateTxReceipt.wait();
        return stateTx;
    }
    async access(accessConfig) {
        return await (0, access_1.access)({
            ...accessConfig,
            ...this.getChainConfig()
        });
    }
    async compute(computeConfig) {
        return await (0, compute_1.compute)({
            ...computeConfig,
            ...this.getChainConfig()
        });
    }
    async getComputeStatus(computeStatusConfig) {
        return await (0, compute_1.getStatus)({
            ...computeStatusConfig,
            signer: this.signer
        });
    }
    async getComputeResult(computeResultConfig) {
        return await (0, compute_1.retrieveResult)({
            ...computeResultConfig,
            signer: this.signer
        });
    }
    async stopCompute(stopComputeConfig) {
        return await (0, compute_1.stopCompute)({
            ...stopComputeConfig,
            signer: this.signer
        });
    }
}
exports.Nautilus = Nautilus;
//# sourceMappingURL=Nautilus.js.map