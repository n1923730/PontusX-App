"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetBuilder = void 0;
const utils_1 = require("../../utils");
const NautilusAsset_1 = require("./NautilusAsset");
const NautilusDDO_1 = require("./NautilusDDO");
class AssetBuilder {
    asset;
    constructor(aquariusAsset) {
        if (aquariusAsset) {
            const nautilusDDO = NautilusDDO_1.NautilusDDO.createFromAquariusAsset(aquariusAsset);
            this.asset = new NautilusAsset_1.NautilusAsset(nautilusDDO);
            this.asset.owner = aquariusAsset.nft.owner;
            this.asset.lifecycleState = aquariusAsset.nft.state;
        }
        else {
            this.asset = new NautilusAsset_1.NautilusAsset();
        }
    }
    reset() {
        this.asset = new NautilusAsset_1.NautilusAsset();
    }
    setType(type) {
        this.asset.ddo.metadata.type = type;
        return this;
    }
    setName(name) {
        this.asset.ddo.metadata.name = name;
        return this;
    }
    setDescription(description) {
        this.asset.ddo.metadata.description = description;
        return this;
    }
    setLicense(license) {
        this.asset.ddo.metadata.license = license;
        return this;
    }
    setAuthor(author) {
        this.asset.ddo.metadata.author = author;
        return this;
    }
    setAlgorithm(algorithm) {
        this.asset.ddo.metadata.algorithm = algorithm;
        return this;
    }
    addService(service) {
        this.asset.ddo.services.push(service);
        return this;
    }
    removeService(serviceId) {
        this.asset.ddo.removeServices.push(serviceId);
        return this;
    }
    setNftData(tokenData) {
        this.asset.nftCreateData = tokenData;
        return this;
    }
    setLifecycleState(state) {
        this.asset.lifecycleState = state;
        return this;
    }
    setOwner(owner) {
        this.asset.owner = owner;
        return this;
    }
    addAdditionalInformation(additionalInformation) {
        this.asset.ddo.metadata.additionalInformation = {
            ...this.asset.ddo.metadata.additionalInformation,
            ...additionalInformation
        };
        return this;
    }
    setCopyrightHolder(copyrightHolder) {
        this.asset.ddo.metadata.copyrightHolder = copyrightHolder;
        return this;
    }
    addTags(tags) {
        this.asset.ddo.metadata.tags = (0, utils_1.combineArrays)(this.asset.ddo.metadata.tags || [], tags);
        return this;
    }
    addLinks(links) {
        this.asset.ddo.metadata.links = (0, utils_1.combineArrays)(this.asset.ddo.metadata.links || [], links);
        return this;
    }
    setContentLanguage(language) {
        this.asset.ddo.metadata.contentLanguage = language;
        return this;
    }
    addCategories(categories) {
        this.asset.ddo.metadata.categories = (0, utils_1.combineArrays)(this.asset.ddo.metadata.categories || [], categories);
        return this;
    }
    addCredentialAddresses(list, addresses) {
        const addressCredentialIndex = this.asset.ddo.credentials[list].findIndex((credential) => credential.type === 'address');
        const oldAddresses = this.asset.ddo.credentials[list][addressCredentialIndex]?.values || [];
        const newAddresses = (0, utils_1.combineArrays)(oldAddresses, addresses);
        if (addressCredentialIndex > -1)
            this.asset.ddo.credentials[list][addressCredentialIndex].values =
                newAddresses;
        else
            this.asset.ddo.credentials[list].push({
                type: 'address',
                values: newAddresses
            });
        return this;
    }
    removeCredentialAddresses(list, addresses) {
        const addressCredentialIndex = this.asset.ddo.credentials[list].findIndex((credential) => credential.type === 'address');
        if (addressCredentialIndex === -1)
            return this;
        const oldAddresses = this.asset.ddo.credentials[list][addressCredentialIndex]?.values;
        const newAddresses = oldAddresses.filter((address) => !addresses.includes(address));
        if (newAddresses.length > 0) {
            this.asset.ddo.credentials[list][addressCredentialIndex].values =
                newAddresses;
        }
        else {
            this.asset.ddo.credentials[list].splice(addressCredentialIndex, 1);
        }
        return this;
    }
    build() {
        return this.asset;
    }
}
exports.AssetBuilder = AssetBuilder;
//# sourceMappingURL=AssetBuilder.js.map