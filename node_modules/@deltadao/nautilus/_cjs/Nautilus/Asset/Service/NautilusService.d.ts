import { type Arweave, type ConsumerParameter, type GraphqlQuery, type Ipfs, type Service, type ServiceComputeOptions, type Smartcontract, type UrlFile } from '@oceanprotocol/lib';
import type { DatatokenCreateParamsWithoutOwner, TrustedAlgorithmAsset } from '../../../@types/Publish';
import type { PricingConfigWithoutOwner } from '../NautilusAsset';
export { Arweave, GraphqlQuery, Ipfs, Smartcontract, UrlFile } from '@oceanprotocol/lib';
export declare enum FileTypes {
    URL = "url",
    GRAPHQL = "graphql",
    ARWEAVE = "arweave",
    IPFS = "ipfs",
    SMARTCONTRACT = "smartcontract"
}
export declare enum ServiceTypes {
    ACCESS = "access",
    COMPUTE = "compute"
}
export type ServiceFileType<FileType extends FileTypes> = FileType extends FileTypes.GRAPHQL ? GraphqlQuery : FileType extends FileTypes.ARWEAVE ? Arweave : FileType extends FileTypes.SMARTCONTRACT ? Smartcontract : FileType extends FileTypes.IPFS ? Ipfs : UrlFile;
export declare class NautilusService<ServiceType extends ServiceTypes, FileType extends FileTypes> {
    type: ServiceType;
    serviceEndpoint: string;
    timeout: number;
    files: ServiceFileType<FileType>[];
    existingEncryptedFiles: string;
    pricing: PricingConfigWithoutOwner;
    newPrice: string;
    datatokenCreateParams: DatatokenCreateParamsWithoutOwner;
    editExistingService: boolean;
    filesEdited: boolean;
    serviceEndpointEdited: boolean;
    name?: string;
    description?: string;
    compute: ServiceComputeOptions;
    addedPublisherTrustedAlgorithms: TrustedAlgorithmAsset[];
    consumerParameters?: ConsumerParameter[];
    additionalInformation?: {
        [key: string]: any;
    };
    id?: string;
    datatokenAddress?: string;
    constructor();
    private initDatatokenData;
    getOceanService(chainId: number, nftAddress: string, dtAddress?: string): Promise<Service>;
    hasValidServiceEndpoint(): Promise<boolean>;
    hasValidFiles(): Promise<boolean>;
    checkIfFilesObjectChanged(): boolean;
}
