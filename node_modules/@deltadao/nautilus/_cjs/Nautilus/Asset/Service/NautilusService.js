"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NautilusService = exports.ServiceTypes = exports.FileTypes = void 0;
const lib_1 = require("@oceanprotocol/lib");
const provider_1 = require("../../../utils/provider");
const datatoken_constants_1 = require("../constants/datatoken.constants");
var FileTypes;
(function (FileTypes) {
    FileTypes["URL"] = "url";
    FileTypes["GRAPHQL"] = "graphql";
    FileTypes["ARWEAVE"] = "arweave";
    FileTypes["IPFS"] = "ipfs";
    FileTypes["SMARTCONTRACT"] = "smartcontract";
})(FileTypes || (exports.FileTypes = FileTypes = {}));
var ServiceTypes;
(function (ServiceTypes) {
    ServiceTypes["ACCESS"] = "access";
    ServiceTypes["COMPUTE"] = "compute";
})(ServiceTypes || (exports.ServiceTypes = ServiceTypes = {}));
class NautilusService {
    type;
    serviceEndpoint;
    timeout;
    files = [];
    existingEncryptedFiles;
    pricing;
    newPrice;
    datatokenCreateParams;
    editExistingService;
    filesEdited;
    serviceEndpointEdited;
    name;
    description;
    compute = {
        allowNetworkAccess: false,
        allowRawAlgorithm: false,
        publisherTrustedAlgorithmPublishers: [],
        publisherTrustedAlgorithms: []
    };
    addedPublisherTrustedAlgorithms = [];
    consumerParameters = [];
    additionalInformation;
    id;
    datatokenAddress;
    constructor() {
        this.editExistingService = false;
        this.filesEdited = false;
        this.initDatatokenData();
    }
    initDatatokenData() {
        this.datatokenCreateParams = datatoken_constants_1.params;
    }
    async getOceanService(chainId, nftAddress, dtAddress) {
        if (!(await this.hasValidServiceEndpoint()))
            throw new Error('serviceEndpoint is not a valid Ocean Provider');
        if (!(await this.hasValidFiles()))
            throw new Error('Some of the provided files could not be validated');
        const datatokenAddress = dtAddress || this.datatokenAddress;
        if (!datatokenAddress)
            throw new Error('datatokenAddress is required');
        const isFilesObjectChanged = this.checkIfFilesObjectChanged();
        let encryptedFiles;
        if (isFilesObjectChanged || !this.existingEncryptedFiles) {
            if (this.files.length < 1) {
                throw new Error('Can not encrypt files. No files defined!');
            }
            const assetURL = {
                datatokenAddress,
                nftAddress,
                files: this.files
            };
            encryptedFiles = await (0, provider_1.getEncryptedFiles)(assetURL, chainId, this.serviceEndpoint);
        }
        else {
            encryptedFiles = this.existingEncryptedFiles;
        }
        const oceanService = {
            id: this.id && !isFilesObjectChanged ? this.id : (0, lib_1.getHash)(encryptedFiles),
            datatokenAddress,
            type: this.type,
            serviceEndpoint: this.serviceEndpoint,
            timeout: this.timeout,
            files: encryptedFiles
        };
        if (this.name)
            oceanService.name = this.name;
        if (this.description)
            oceanService.description = this.description;
        if (this.additionalInformation)
            oceanService.additionalInformation = this.additionalInformation;
        if (this.consumerParameters.length > 0)
            oceanService.consumerParameters = this.consumerParameters;
        if (this.type === ServiceTypes.COMPUTE)
            oceanService.compute = this.compute;
        return oceanService;
    }
    async hasValidServiceEndpoint() {
        return await (0, provider_1.isValidProvider)(this.serviceEndpoint);
    }
    async hasValidFiles() {
        for (const file of this.files) {
            const fileInfo = await (0, provider_1.getFileInfo)(file, this.serviceEndpoint);
            if (fileInfo.some((info) => !info.valid))
                return false;
        }
        return true;
    }
    checkIfFilesObjectChanged() {
        return ((this.editExistingService &&
            (this.filesEdited || this.serviceEndpointEdited)) ||
            !!this.pricing);
    }
}
exports.NautilusService = NautilusService;
//# sourceMappingURL=NautilusService.js.map