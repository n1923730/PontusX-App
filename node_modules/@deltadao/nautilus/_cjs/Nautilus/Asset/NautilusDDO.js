"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NautilusDDO = void 0;
const lib_1 = require("@oceanprotocol/lib");
const utils_1 = require("../../utils");
const aquarius_1 = require("../../utils/aquarius");
class NautilusDDO {
    id;
    context = ['https://w3id.org/did/v1'];
    nftAddress;
    chainId;
    version = '4.1.0';
    metadata = {};
    services = [];
    removeServices = [];
    ddo;
    credentials = {
        allow: [],
        deny: []
    };
    static createFromAquariusAsset(aquariusAsset) {
        const ddo = (0, aquarius_1.transformAquariusAssetToDDO)(aquariusAsset);
        return NautilusDDO.createFromDDO(ddo);
    }
    static createFromDDO(ddo) {
        const nautilusDDO = new NautilusDDO();
        nautilusDDO.ddo = ddo;
        nautilusDDO.id = ddo.id;
        nautilusDDO.context = ddo['@context'];
        nautilusDDO.nftAddress = ddo.nftAddress;
        nautilusDDO.chainId = ddo.chainId;
        nautilusDDO.version = ddo.version;
        if (ddo.credentials?.allow)
            nautilusDDO.credentials.allow = ddo.credentials.allow;
        if (ddo.credentials?.deny)
            nautilusDDO.credentials.deny = ddo.credentials.deny;
        return nautilusDDO;
    }
    getOriginalDDO() {
        return this.ddo;
    }
    async buildDDOServices() {
        if (this.services.length < 1)
            throw new Error('At least one service needs to be defined.');
        const servicesWithEncryptedFiles = await (0, utils_1.getAllPromisesOnArray)(this.services, async (service) => {
            return await service.getOceanService(this.chainId, this.nftAddress);
        });
        return servicesWithEncryptedFiles;
    }
    buildDDOMetadata(create) {
        const currentTime = (0, utils_1.dateToStringNoMS)(new Date());
        const newMetadata = {
            ...this.ddo?.metadata,
            ...this.metadata,
            created: create ? currentTime : this.ddo?.metadata.created,
            updated: currentTime
        };
        return newMetadata;
    }
    async getDDOServices() {
        const existingServices = this.ddo?.services || [];
        for (const service of this.services) {
            const isFilesObjectChanged = service.checkIfFilesObjectChanged();
            if (service.id && isFilesObjectChanged) {
                this.removeServices.push(service.id);
            }
        }
        let newServices;
        if (this.services.length > 0) {
            newServices = await this.buildDDOServices();
        }
        this.removeServices = (0, utils_1.removeDuplicatesFromArray)(this.removeServices);
        const reducedExistingServices = existingServices.filter((service) => !this.removeServices.includes(service.id));
        let replacedServices;
        if (this.services.length > 0) {
            replacedServices = (0, utils_1.combineArraysAndReplaceItems)(reducedExistingServices, newServices, NautilusDDO.replaceServiceBasedOnId);
        }
        return replacedServices || reducedExistingServices;
    }
    async buildDDO(create) {
        if (create) {
            if (!this.nftAddress || !this.chainId)
                throw new Error('When creating a new DDO, nftAddress and chainId are required.');
            this.id = (0, lib_1.generateDid)(this.nftAddress, this.chainId);
        }
        const newMetadata = this.buildDDOMetadata(create);
        const newServices = await this.getDDOServices();
        this.ddo = {
            ...this.ddo,
            id: this.id,
            '@context': this.context,
            nftAddress: this.nftAddress,
            chainId: this.chainId,
            version: this.version,
            metadata: newMetadata,
            services: newServices,
            credentials: this.credentials
        };
        return this.ddo;
    }
    async getDDO(createDDOData = {
        create: false
    }) {
        const { create, chainId, nftAddress } = createDDOData;
        if (chainId)
            this.chainId = chainId;
        if (nftAddress)
            this.nftAddress = nftAddress;
        if (create && !this.hasAllRequiredOceanDDOAttributes())
            throw new Error('Required attributes are missing to create a valid Ocean DDO');
        return this.buildDDO(create);
    }
    hasAllRequiredOceanDDOAttributes() {
        if (this.ddo)
            return true;
        if (!this.chainId || !this.nftAddress || !this.context || !this.version)
            return false;
        if (!this.metadata.name ||
            !this.metadata.description ||
            !this.metadata.type ||
            !this.metadata.author ||
            !this.metadata.license)
            return false;
        if (this.metadata.type === 'algorithm')
            if (!this.metadata.algorithm ||
                !this.metadata.algorithm.container ||
                !this.metadata.algorithm.container.entrypoint ||
                !this.metadata.algorithm.container.image ||
                !this.metadata.algorithm.container.tag ||
                !this.metadata.algorithm.container.checksum)
                return false;
        return true;
    }
    static replaceServiceBasedOnId(service, potentialReplacements) {
        const replacementService = potentialReplacements.find((potentialReplacement) => potentialReplacement.id === service.id);
        if (!replacementService)
            return service;
        return replacementService;
    }
}
exports.NautilusDDO = NautilusDDO;
//# sourceMappingURL=NautilusDDO.js.map