"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.order = exports.reuseOrder = exports.isOrderable = void 0;
const lib_1 = require("@oceanprotocol/lib");
const _1 = require(".");
async function isOrderable(asset, serviceId, algorithm, algorithmAsset) {
    const datasetService = (0, _1.getServiceById)(asset, serviceId);
    if (!datasetService)
        return false;
    if (datasetService.type === 'compute') {
        if (algorithm.meta) {
            if (datasetService.compute.allowRawAlgorithm)
                return true;
            lib_1.LoggerInstance.error('ERROR: This service does not allow raw algorithm');
            return false;
        }
        if (algorithm.documentId) {
            const algoService = (0, _1.getServiceById)(algorithmAsset, algorithm.serviceId);
            if (algoService && algoService.type === 'compute') {
                if (algoService.serviceEndpoint !== datasetService.serviceEndpoint) {
                    lib_1.LoggerInstance.error('ERROR: Both assets with compute service are not served by the same provider');
                    return false;
                }
            }
        }
    }
    return true;
}
exports.isOrderable = isOrderable;
async function reuseOrder({ signer, asset, validOrderTx, providerFees }) {
    const datatoken = new lib_1.Datatoken(signer);
    const tx = await datatoken.reuseOrder(asset.accessDetails.datatoken.address, validOrderTx, providerFees);
    return tx;
}
exports.reuseOrder = reuseOrder;
async function order({ signer, asset, orderPriceAndFees, accountId, config, providerFees, computeConsumerAddress }) {
    const datatoken = new lib_1.Datatoken(signer);
    const orderParams = {
        consumer: computeConsumerAddress || accountId,
        serviceIndex: 0,
        _providerFee: providerFees,
        _consumeMarketFee: {
            consumeMarketFeeAddress: lib_1.ZERO_ADDRESS,
            consumeMarketFeeAmount: '0',
            consumeMarketFeeToken: '0x0000000000000000000000000000000000000000'
        }
    };
    lib_1.LoggerInstance.debug('[order] orderParams', orderParams);
    lib_1.LoggerInstance.debug('[order] order type', asset.accessDetails?.type);
    const templateId = Number(asset.accessDetails?.templateId);
    lib_1.LoggerInstance.debug('[order] order templateId', templateId);
    switch (asset.accessDetails?.type) {
        case 'fixed': {
            const freParams = {
                exchangeContract: config.fixedRateExchangeAddress,
                exchangeId: asset.accessDetails.addressOrId,
                maxBaseTokenAmount: orderPriceAndFees.price,
                baseTokenAddress: asset?.accessDetails?.baseToken?.address,
                baseTokenDecimals: asset?.accessDetails?.baseToken?.decimals || 18,
                swapMarketFee: '0',
                marketFeeAddress: lib_1.ZERO_ADDRESS
            };
            if (templateId === 1) {
                const tx = await (0, lib_1.approve)(signer, config, accountId, asset.accessDetails.baseToken.address, config.fixedRateExchangeAddress, await (0, lib_1.amountToUnits)(signer, asset?.accessDetails?.baseToken?.address, orderPriceAndFees.price, asset?.accessDetails?.baseToken?.decimals), false);
                const txApprove = typeof tx !== 'number' ? await tx.wait() : tx;
                if (!txApprove) {
                    lib_1.LoggerInstance.error('Unable to approve datatoken tx');
                    return;
                }
                const fre = new lib_1.FixedRateExchange(config.fixedRateExchangeAddress, signer);
                const freTx = await fre.buyDatatokens(asset.accessDetails?.addressOrId, '1', orderPriceAndFees.price, lib_1.ZERO_ADDRESS, '0');
                await freTx.wait();
                return await datatoken.startOrder(asset.accessDetails.datatoken.address, orderParams.consumer, orderParams.serviceIndex, orderParams._providerFee, orderParams._consumeMarketFee);
            }
            if (templateId === 2) {
                const tx = await (0, lib_1.approve)(signer, config, accountId, asset.accessDetails.baseToken.address, asset.accessDetails.datatoken.address, await (0, lib_1.amountToUnits)(signer, asset?.accessDetails?.baseToken?.address, orderPriceAndFees.price, asset?.accessDetails?.baseToken?.decimals), false);
                const txApprove = typeof tx !== 'number' ? await tx.wait() : tx;
                if (!txApprove) {
                    lib_1.LoggerInstance.error('Unable to approve datatoken tx');
                    return;
                }
                return await datatoken.buyFromFreAndOrder(asset.accessDetails.datatoken.address, orderParams, freParams);
            }
            break;
        }
        case 'free': {
            lib_1.LoggerInstance.debug('[order] order with type "free" for templateId:', templateId);
            if (templateId === 1) {
                const dispenser = new lib_1.Dispenser(config.dispenserAddress, signer);
                lib_1.LoggerInstance.debug('[order] free order: dispenser', dispenser.address);
                const dispenserTx = await dispenser.dispense(asset.accessDetails?.datatoken.address, '1', accountId);
                await dispenserTx.wait();
                lib_1.LoggerInstance.debug('[order] free order: dispenser tx', dispenserTx.hash);
                return await datatoken.startOrder(asset.accessDetails.datatoken.address, orderParams.consumer, orderParams.serviceIndex, orderParams._providerFee, orderParams._consumeMarketFee);
            }
            if (templateId === 2) {
                lib_1.LoggerInstance.debug('[order] buying from datatoken', {
                    datatoken: asset.services[0].datatokenAddress,
                    accountId,
                    orderParams,
                    dispenser: config.dispenserAddress
                });
                try {
                    return await datatoken.buyFromDispenserAndOrder(asset.services[0].datatokenAddress, orderParams, config.dispenserAddress);
                }
                catch (e) {
                    throw new Error(e);
                }
            }
            break;
        }
    }
}
exports.order = order;
//# sourceMappingURL=order.js.map