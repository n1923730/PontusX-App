"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformAquariusAssetToDDO = exports.getAssets = exports.getAsset = void 0;
const lib_1 = require("@oceanprotocol/lib");
const axios_1 = __importDefault(require("axios"));
const constants_1 = require("./constants");
async function getAsset(metadataCacheUri, did, signal) {
    lib_1.LoggerInstance.debug(`[aquarius] Retrieve asset ${did} using cache at ${metadataCacheUri}`);
    if (!did || !metadataCacheUri)
        return;
    try {
        const apiPath = `/api/aquarius/assets/ddo/${did}`;
        const fullAquariusUrl = new URL(apiPath, metadataCacheUri).href;
        const response = await axios_1.default.get(fullAquariusUrl, {
            signal
        });
        if (!response || response.status !== 200 || !response.data)
            return;
        const data = { ...response.data };
        return data;
    }
    catch (error) {
        if (axios_1.default.isCancel(error)) {
            lib_1.LoggerInstance.log(error.message);
        }
        else {
            lib_1.LoggerInstance.error(error.message);
        }
        throw error;
    }
}
exports.getAsset = getAsset;
async function getAssets(metadataCacheUri, dids) {
    const apiPath = '/api/aquarius/assets/query';
    if (!metadataCacheUri) {
        throw new Error('[aquarius] No metadata cache URI provided');
    }
    if (!dids?.length) {
        throw new Error('[aquarius] The DIDs array is empty');
    }
    const lowerCaseDids = dids.map((did) => did.toLowerCase());
    const queryPayload = {
        query: {
            bool: {
                filter: [
                    {
                        ids: {
                            values: lowerCaseDids
                        }
                    }
                ]
            }
        }
    };
    const assets = {};
    try {
        const fullAquariusUrl = new URL(apiPath, metadataCacheUri).href;
        const response = await axios_1.default.post(fullAquariusUrl, queryPayload);
        lib_1.LoggerInstance.debug(`[aquarius] Query status: ${response.status}`);
        if (response?.status === 200 && response?.data?.hits) {
            for (const hit of response.data.hits.hits) {
                const asset = hit._source;
                if (asset?.id) {
                    assets[asset.id.toLowerCase()] = asset;
                }
            }
        }
        return assets;
    }
    catch (error) {
        lib_1.LoggerInstance.error(`Error in retrieving assets: ${error.message}`);
        throw error;
    }
}
exports.getAssets = getAssets;
function transformAquariusAssetToDDO(aquariusAsset) {
    const ddo = structuredClone(aquariusAsset);
    for (const attribute of constants_1.AQUARIUS_ASSET_EXTENDED_DDO_PROPS) {
        delete ddo[attribute];
    }
    return ddo;
}
exports.transformAquariusAssetToDDO = transformAquariusAssetToDDO;
//# sourceMappingURL=aquarius.js.map