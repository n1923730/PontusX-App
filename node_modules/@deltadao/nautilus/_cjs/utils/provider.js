"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileInfo = exports.approveProviderFee = exports.getValidUntilTime = exports.stopComputeJob = exports.startComputeJob = exports.initializeProviderForCompute = exports.initializeProvider = exports.checkDidFiles = exports.getEncryptedFiles = exports.isValidProvider = void 0;
const lib_1 = require("@oceanprotocol/lib");
const _1 = require(".");
async function isValidProvider(providerUrl) {
    try {
        const response = await lib_1.ProviderInstance.isValidProvider(providerUrl);
        return response;
    }
    catch (error) {
        lib_1.LoggerInstance.error(`Error verifying provider instance: ${error.message}`);
        return false;
    }
}
exports.isValidProvider = isValidProvider;
async function getEncryptedFiles(files, chainId, providerUrl) {
    try {
        lib_1.LoggerInstance.debug('Encrytping files:');
        lib_1.LoggerInstance.debug({ files, chainId, providerUrl });
        const response = await lib_1.ProviderInstance.encrypt(files, chainId, providerUrl);
        return response;
    }
    catch (error) {
        lib_1.LoggerInstance.error(`Error parsing json: ${error.message}`);
    }
}
exports.getEncryptedFiles = getEncryptedFiles;
async function checkDidFiles(did, serviceId, providerUrl) {
    try {
        const response = await lib_1.ProviderInstance.checkDidFiles(did, serviceId, providerUrl, true);
        return response;
    }
    catch (error) {
        throw new Error(`[Initialize check file did] Error:' ${error}`);
    }
}
exports.checkDidFiles = checkDidFiles;
async function initializeProvider(asset, accountId, service, fileIndex = 0, consumerParameters) {
    try {
        return await lib_1.ProviderInstance.initialize(asset.id, service.id, fileIndex, accountId, service.serviceEndpoint, undefined, consumerParameters);
    }
    catch (error) {
        lib_1.LoggerInstance.error('Error initializing provider for access!');
        lib_1.LoggerInstance.error(error);
        return null;
    }
}
exports.initializeProvider = initializeProvider;
async function initializeProviderForCompute(dataset, algorithm, accountId, computeEnv = null) {
    const computeAsset = {
        documentId: dataset.id,
        serviceId: dataset.services[0].id,
        transferTxId: dataset.accessDetails.validOrderTx
    };
    const computeAlgo = {
        documentId: algorithm.id,
        serviceId: algorithm.services[0].id,
        transferTxId: algorithm.accessDetails.validOrderTx
    };
    const validUntil = getValidUntilTime(computeEnv?.maxJobDuration, dataset.services[0].timeout, algorithm.services[0].timeout);
    try {
        return await lib_1.ProviderInstance.initializeCompute([computeAsset], computeAlgo, computeEnv?.id, validUntil, dataset.services[0].serviceEndpoint, accountId);
    }
    catch (error) {
        lib_1.LoggerInstance.error(`Error initializing provider for the compute job! ${error.message}`);
        return null;
    }
}
exports.initializeProviderForCompute = initializeProviderForCompute;
async function startComputeJob(providerUri, dataset, algorithm, signer, computeEnv, output) {
    try {
        return await lib_1.ProviderInstance.computeStart(providerUri, signer, computeEnv?.id, dataset, algorithm, null, null, output);
    }
    catch (error) {
        lib_1.LoggerInstance.error('Error starting compute job!');
        lib_1.LoggerInstance.error(error);
    }
}
exports.startComputeJob = startComputeJob;
async function stopComputeJob(providerUri, did, jobId, signer) {
    try {
        return await lib_1.ProviderInstance.computeStop(did, await signer.getAddress(), jobId, providerUri, signer);
    }
    catch (error) {
        lib_1.LoggerInstance.error('Error stopping compute job!');
        lib_1.LoggerInstance.error(error);
    }
}
exports.stopComputeJob = stopComputeJob;
function getValidUntilTime(computeEnvMaxJobDuration, datasetTimeout, algorithmTimeout) {
    const inputValues = [];
    computeEnvMaxJobDuration && inputValues.push(computeEnvMaxJobDuration);
    datasetTimeout && inputValues.push(datasetTimeout);
    algorithmTimeout && inputValues.push(algorithmTimeout);
    const minValue = Math.min(...inputValues);
    const mytime = new Date();
    mytime.setMinutes(mytime.getMinutes() + Math.floor(minValue / 60));
    return Math.floor(mytime.getTime() / 1000);
}
exports.getValidUntilTime = getValidUntilTime;
async function approveProviderFee(asset, accountId, signer, providerFeeAmount) {
    const config = (0, _1.getOceanConfig)(asset.chainId);
    const baseToken = asset?.accessDetails?.type === 'free'
        ? (0, _1.getOceanConfig)(asset.chainId).oceanTokenAddress
        : asset?.accessDetails?.baseToken?.address;
    const txApproveWei = await (0, lib_1.approveWei)(signer, config, accountId, baseToken, asset?.accessDetails?.datatoken?.address, providerFeeAmount);
    return txApproveWei;
}
exports.approveProviderFee = approveProviderFee;
async function getFileInfo(file, providerUri, withChecksum) {
    return await lib_1.ProviderInstance.getFileInfo(file, providerUri, withChecksum);
}
exports.getFileInfo = getFileInfo;
//# sourceMappingURL=provider.js.map