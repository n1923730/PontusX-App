"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccessDetailsFromTokenPrice = exports.fetchData = exports.geturqlClient = exports.getQueryContext = void 0;
const lib_1 = require("@oceanprotocol/lib");
const urql_1 = require("urql");
let client;
function getQueryContext(subgraphUri) {
    try {
        const queryContext = {
            url: `${subgraphUri}/subgraphs/name/oceanprotocol/ocean-subgraph`,
            requestPolicy: 'network-only'
        };
        return queryContext;
    }
    catch (error) {
        lib_1.LoggerInstance.error('Get query context error: ', error.message);
    }
}
exports.getQueryContext = getQueryContext;
function geturqlClient(subgraphUri) {
    if (!client)
        client = (0, urql_1.createClient)({
            url: `${subgraphUri}/subgraphs/name/oceanprotocol/ocean-subgraph`,
            exchanges: [urql_1.dedupExchange, urql_1.fetchExchange]
        });
    return client;
}
exports.geturqlClient = geturqlClient;
async function fetchData(subgraphUri, query, variables, context) {
    try {
        const client = geturqlClient(subgraphUri);
        const response = await client
            .query(query, variables, context)
            .toPromise();
        return response;
    }
    catch (error) {
        lib_1.LoggerInstance.error('Error fetchData: ', error.message);
    }
    return null;
}
exports.fetchData = fetchData;
function getAccessDetailsFromTokenPrice(tokenPrice, timeout) {
    const accessDetails = {};
    if (tokenPrice?.dispensers?.length === 0 &&
        tokenPrice?.fixedRateExchanges?.length === 0) {
        accessDetails.type = 'NOT_SUPPORTED';
        return accessDetails;
    }
    if (tokenPrice?.orders?.length > 0) {
        const order = tokenPrice.orders[0];
        const reusedOrder = order?.reuses?.length > 0 ? order.reuses[0] : null;
        accessDetails.isOwned =
            timeout === 0 || Date.now() / 1000 - order?.createdTimestamp < timeout;
        accessDetails.validOrderTx = reusedOrder?.tx || order?.tx;
    }
    accessDetails.templateId = tokenPrice.templateId;
    accessDetails.publisherMarketOrderFee = tokenPrice?.publishMarketFeeAmount;
    if (tokenPrice?.dispensers?.length > 0) {
        const dispenser = tokenPrice.dispensers[0];
        accessDetails.type = 'free';
        accessDetails.addressOrId = dispenser.token.id;
        accessDetails.price = '0';
        accessDetails.isPurchasable = dispenser.active;
        accessDetails.datatoken = {
            address: dispenser.token.id,
            name: dispenser.token.name,
            symbol: dispenser.token.symbol
        };
    }
    if (tokenPrice?.fixedRateExchanges?.length > 0) {
        const fixed = tokenPrice.fixedRateExchanges[0];
        accessDetails.type = 'fixed';
        accessDetails.addressOrId = fixed.exchangeId;
        accessDetails.price = fixed.price;
        accessDetails.isPurchasable = fixed.active;
        accessDetails.baseToken = {
            address: fixed.baseToken.address,
            name: fixed.baseToken.name,
            symbol: fixed.baseToken.symbol,
            decimals: fixed.baseToken.decimals
        };
        accessDetails.datatoken = {
            address: fixed.datatoken.address,
            name: fixed.datatoken.name,
            symbol: fixed.datatoken.symbol
        };
    }
    return accessDetails;
}
exports.getAccessDetailsFromTokenPrice = getAccessDetailsFromTokenPrice;
//# sourceMappingURL=index.js.map