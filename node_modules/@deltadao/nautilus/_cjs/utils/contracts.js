"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.editPrice = void 0;
const lib_1 = require("@oceanprotocol/lib");
const access_details_1 = require("./helpers/access-details");
async function editPrice(aquariusAsset, serviceId, newPrice, chainConfig, signer) {
    if (!aquariusAsset) {
        throw new Error('[editPrice] Aquarius asset is undefined');
    }
    if (!aquariusAsset.services || aquariusAsset.services.length === 0) {
        throw new Error('[editPrice] Aquarius asset has no services');
    }
    const service = aquariusAsset.services.find((service) => service.id === serviceId);
    if (!service) {
        throw new Error('[editPrice] No matching service found for provided serviceId');
    }
    const fixedRateInstance = new lib_1.FixedRateExchange(chainConfig.fixedRateExchangeAddress, signer);
    let accessDetails;
    try {
        accessDetails = await (0, access_details_1.getAccessDetails)(chainConfig.subgraphUri, service.datatokenAddress);
    }
    catch (error) {
        lib_1.LoggerInstance.error(`[editPrice] Error fetching access details: ${error.message}`);
        throw error;
    }
    let txReceipt;
    try {
        const tx = await fixedRateInstance.setRate(accessDetails.addressOrId, newPrice);
        txReceipt = await tx.wait();
    }
    catch (error) {
        lib_1.LoggerInstance.error(`[editPrice] Error setting new price (setRate): ${error.message}`);
        throw error;
    }
    return txReceipt;
}
exports.editPrice = editPrice;
//# sourceMappingURL=contracts.js.map