"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePublisherTrustedAlgorithms = void 0;
const lib_1 = require("@oceanprotocol/lib");
const aquarius_1 = require("../aquarius");
const provider_1 = require("../provider");
async function getPublisherTrustedAlgorithms(dids, metadataCacheUri) {
    const trustedAlgorithms = [];
    const assetPromises = dids.map((did) => (0, aquarius_1.getAsset)(metadataCacheUri, did));
    let assets = [];
    try {
        assets = await Promise.all(assetPromises);
    }
    catch (error) {
        throw new Error(`Failed to fetch assets for PublisherTrustedAlgorithms: ${error}`);
    }
    for (const asset of assets) {
        if (asset.metadata.type !== 'algorithm')
            throw new Error(`Asset ${asset.id} is not of type algorithm`);
        if (!asset.services?.[0])
            throw new Error(`No service in ${asset.id}`);
        const filesChecksum = await (0, provider_1.checkDidFiles)(asset?.id, asset?.services?.[0]?.id, asset?.services?.[0]?.serviceEndpoint);
        if (!filesChecksum?.[0]?.checksum)
            throw new Error(`Unable to get fileChecksum for asset ${asset.id}`);
        const containerChecksum = asset.metadata.algorithm.container.entrypoint +
            asset.metadata.algorithm.container.checksum;
        const trustedAlgorithm = {
            did: asset.id,
            containerSectionChecksum: (0, lib_1.getHash)(containerChecksum),
            filesChecksum: filesChecksum?.[0]?.checksum
        };
        trustedAlgorithms.push(trustedAlgorithm);
    }
    return trustedAlgorithms;
}
async function resolvePublisherTrustedAlgorithms(nautilusDDOServices, metadataCacheUri) {
    for (const service of nautilusDDOServices) {
        if (service.addedPublisherTrustedAlgorithms?.length < 1)
            continue;
        const dids = service.addedPublisherTrustedAlgorithms.map((asset) => asset.did);
        const newPublisherTrustedAlgorithms = await getPublisherTrustedAlgorithms(dids, metadataCacheUri);
        if (service.compute?.publisherTrustedAlgorithms?.length === 0) {
            service.compute.publisherTrustedAlgorithms = newPublisherTrustedAlgorithms;
            continue;
        }
        for (const algorithm of newPublisherTrustedAlgorithms) {
            const index = service.compute.publisherTrustedAlgorithms.findIndex((existingAlgorithm) => existingAlgorithm.did === algorithm.did);
            if (index === -1) {
                service.compute.publisherTrustedAlgorithms.push(algorithm);
            }
            else {
                const existing = service.compute.publisherTrustedAlgorithms[index];
                if (existing.containerSectionChecksum !==
                    algorithm.containerSectionChecksum ||
                    existing.filesChecksum !== algorithm.filesChecksum) {
                    service.compute.publisherTrustedAlgorithms[index] = algorithm;
                }
            }
        }
    }
}
exports.resolvePublisherTrustedAlgorithms = resolvePublisherTrustedAlgorithms;
//# sourceMappingURL=trusted-algorithms.js.map